<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ministry of Defence</title>
    <!-- Add a link to your favicon -->
    <link rel="icon" href="https://i.pinimg.com/474x/f7/2a/b4/f72ab43202047860f3dace2bd2728502.jpg" type="image/x-icon">
    <style>
        /* --- Google Font --- */
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap');

        /* --- Base Styles & Body --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(45deg, #09203f 0%, #537895 100%); /* Dark blue gradient */
            height: 100vh;
            overflow: hidden; /* Hide scrollbars and keep hearts contained */
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background 0.5s ease;
        }

        /* New class to apply the love theme background when chat is active */
        body.chat-active {
            /* A simple gradient for the chat view */
            background: linear-gradient(45deg, #1d2b3c 0%, #2f4858 100%);
        }

        /* --- Main Chat Container --- */
        .chat-app-container {
            display: flex;
            gap: 40px;
            padding: 20px;
            width: 90%;
            max-width: 1200px;
            position: relative; /* Ensure content is above the emojis */
            z-index: 1; /* Make sure chat container is on top of background elements */
            border-radius: 25px;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
            overflow: hidden; /* Hide overflowing parts of the slideshow */
        }

        /* --- Background Slideshow --- */
        .background-slideshow {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* Behind all content */
            background-size: contain; /* Changed from cover to contain */
            background-position: center;
            background-repeat: no-repeat; /* Prevent image from repeating */
            animation: slide 9s infinite;
            background-color: rgba(0, 0, 0, 0.5); /* Fallback for empty space */
        }

@keyframes slide {
    0%, 30%, 100% {
        background-image: url('https://i.pinimg.com/236x/f3/63/5c/f3635c7ae1d6779135957b8cccd6cdca.jpg'); /* Army */
        opacity: 1;
    }
    33%, 63% {
        background-image: url('https://i.pinimg.com/474x/7b/e0/6e/7be06eb6e6a0dddda7f24a9758ff7c43.jpg'); /* Navy */
        opacity: 1;
    }
    66%, 97% {
        background-image: url('https://w0.peakpx.com/wallpaper/385/554/HD-wallpaper-indian-air-force-abhinandhan-air-force-army-best-india-logo-modi-navy-soldiers-war.jpg'); /* Air Force */
        opacity: 1;
    }
}
        }

        /* Hide the slideshow when the chat is active */
        body.chat-active .background-slideshow {
            display: none;
        }

        /* --- Individual Chat Box Styling --- */
        .chat-box {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(10px);
            border-radius: 25px; /* The curved rectangle effect */
            border: 1px solid rgba(255, 255, 255, 0.18);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
            height: 85vh;
            max-height: 700px;
        }

        .chat-header {
            position: relative;
            padding: 20px;
            background: rgba(255, 255, 255, 0.4); /* Made slightly more opaque */
            border-bottom: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 25px 25px 0 0;
            text-align: center;
            font-size: 1.2rem;
            font-weight: 600;
            color: #d6336c; /* A lovely pink color */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            display: flex;
            justify-content: center; /* Center content */
            align-items: center;
            flex-wrap: wrap; /* Allow items to wrap to the next line */
            gap: 10px 20px; /* Add row and column gap */
        }

        .user-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex-grow: 1; /* Allow it to take space */
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.8rem;
            font-weight: 400;
            color: #888;
            margin-top: 2px;
        }
        .status-dot { width: 8px; height: 8px; background-color: #888; border-radius: 50%; transition: background-color 0.3s; }
        .status-indicator.online .status-dot { background-color: #2ecc71; }
        .status-indicator.online .status-text { color: #2ecc71; }




        .chat-messages {
            flex-grow: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        /* Custom scrollbar for a cleaner look */
        .chat-messages::-webkit-scrollbar {
            width: 6px;
        }
        .chat-messages::-webkit-scrollbar-thumb {
            background: rgba(214, 51, 108, 0.4);
            border-radius: 3px;
        }

        .chat-input-area {
            display: flex;
            padding: 15px;
            position: relative; /* For emoji picker positioning */
            border-top: 1px solid rgba(255, 255, 255, 0.18);
            background: rgba(255, 255, 255, 0.4); /* Added background to make it clearer */
            border-radius: 0 0 25px 25px; /* Match the chat box's bottom corners */
        }

        .chat-input {
            flex-grow: 1;
            min-width: 0; /* Crucial for allowing the input to shrink in flexbox */
            border: none;
            padding: 12px 15px;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.5);
            font-family: 'Poppins', sans-serif;
            font-size: 1rem;
            color: #333;
        }

        /* --- Header Menu & Dropdown --- */
        .header-menu {
            position: absolute;
            top: 15px;
            right: 15px;
        }

        .menu-toggle-button {
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 4px;
            padding: 8px;
        }

        .menu-toggle-button span {
            display: block;
            width: 100%;
            height: 2px;
            background-color: #d6336c;
            border-radius: 1px;
            transition: all 0.3s ease-in-out;
        }

        .menu-dropdown {
            position: absolute;
            top: 50px; /* Position below the button */
            right: 0;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            width: 200px;
            overflow: hidden;
            z-index: 10;
            opacity: 0;
            transform: translateY(-10px);
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
        }

        .menu-dropdown.visible {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .menu-dropdown button {
            display: flex;
            align-items: center;
            gap: 12px;
            width: 100%;
            padding: 12px 15px;
            text-align: left;
            font-size: 0.9rem;
            color: #333;
        }
        .menu-dropdown button:hover { background-color: #f0f0f0; transform: none; }
        .chat-input:focus {
            outline: none;
            box-shadow: 0 0 0 2px #d6336c;
        }

        .attach-button {
            padding: 0 12px;
            border: none;
            background: none;
            font-size: 1.4rem;
            cursor: pointer;
            color: #555;
            transition: transform 0.2s;
        }
        .attach-button:hover {
            transform: scale(1.1);
        }
        .camera-button {
            padding: 0 12px;
            border: none;
            background: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #555;
            transition: transform 0.2s;
        }
        .camera-button:hover {
            transform: scale(1.1);
        }
        .voice-record-button {
            padding: 0 12px;
            border: none;
            background: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #555;
            transition: color 0.2s, transform 0.2s;
        }
        .voice-record-button:hover {
            transform: scale(1.1);
        }
        .voice-record-button.recording {
            color: #ff4d4d; /* Red color when recording */
            animation: pulseRecording 1.5s infinite;
        }
        .audio-preview {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
        }
        .preview-audio-player {
            flex-grow: 1;
            height: 40px;
        }
        .delete-audio-button {
            padding: 0 12px;
            border: none;
            background: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #555;
            transition: color 0.2s, transform 0.2s;
        }
        .delete-audio-button:hover {
            color: #ff4d4d;
            transform: scale(1.1);
        }


        .send-icon-button {
            padding: 0 15px;
            border: none;
            background: none;
            font-size: 1.6rem;
            cursor: pointer;
            color: #d6336c; /* Use the theme color */
            transition: transform 0.2s;
            margin-left: 5px;
            transform-origin: center;
        }
        .send-icon-button:hover {
            transform: scale(1.15);
        }
        /* --- Message Bubble Styling --- */
        .message {
            padding: 10px 15px;
            border-radius: 18px;
            max-width: 70%;
            word-wrap: break-word;
            display: flex;
            flex-direction: column;
            animation: fadeInMessage 0.4s ease-out;
        }

        .message-content {
            /* The actual text of the message */
        }

        .message-image {
            max-width: 100%;
            max-height: 250px;
            border-radius: 10px;
            margin-bottom: 5px; /* Space between image and meta */
            object-fit: cover;
            cursor: pointer;
        }
        .message-video {
            max-width: 100%;
            max-height: 250px;
            border-radius: 10px;
            margin-bottom: 5px; /* Space between video and meta */
            background-color: #000;
        }
        .message-audio {
            display: none; /* We will use a custom player */
        }

        .custom-audio-player {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%; /* Take full width of its container */
            max-width: 400px; /* Further increased length */
            padding: 5px 0;
        }

        .play-pause-btn {
            background: #d6336c;
            border: none;
            width: 30px; /* Decreased height */
            height: 30px; /* Decreased height */
            border-radius: 50%;
            color: white;
            font-size: 1rem; /* Adjusted for smaller button */
            cursor: pointer;
            padding: 0;
            line-height: 0; /* Helps center the icon */
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0; /* Prevent button from shrinking */
            transition: background-color 0.2s;
        }

        .message.received .play-pause-btn {
            background-color: #e9ecef;
            color: #d6336c;
        }
        
        .waveform-container {
            display: flex;
            align-items: center;
            height: 30px; /* Match play button height */
            flex-grow: 1;
            gap: 2px;
            cursor: pointer;
        }

        .waveform-bar {
            width: 3px;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 2px;
            transition: background-color 0.05s linear;
        }

        .message.sent .waveform-bar {
            background-color: rgba(255, 255, 255, 0.4);
        }

        .waveform-bar.played {
            background-color: #fff; /* Active color for sent messages */
        }

        .message.received .waveform-bar.played {
            background-color: #d6336c;
        }

        .audio-duration {
            font-size: 0.75rem;
            color: rgba(0, 0, 0, 0.5);
            margin-left: 10px;
            flex-shrink: 0;
        }

        .message-timestamp {
            font-size: 0.75rem;
            /* margin-top: 5px; */ /* No longer needed with flex */
            align-self: flex-end;
        }

        .message.sent .audio-duration {
            color: rgba(255, 255, 255, 0.8);
        }

        .message-meta {
            display: flex;
            align-items: center;
            justify-content: space-between; /* Pushes children to opposite ends */
            width: 100%; /* Ensure it takes full width */
            margin-top: 5px;
        }

        .message-meta-right {
            display: flex;
            align-items: center;
            gap: 5px;
        }


        .message-status {
            font-size: 0.9rem;
            font-weight: 600;
        }

        .message-seen-info {
            display: flex;
            gap: 8px;
            font-size: 0.7rem;
            font-style: italic;
            color: rgba(255, 255, 255, 0.7);
            align-self: flex-end;
        }

        .message.sent .message-timestamp {
            color: rgba(255, 255, 255, 0.8);
        }

        .message.sent .message-status {
            color: rgba(255, 255, 255, 0.8); /* Default gray-ish 'delivered' color */
        }
        .message.sent .message-status.seen {
            color: #4fc3f7; /* A nice blue for 'seen' */
        }

        .message.sent {
            background-color: #d6336c;
            color: white;
            align-self: flex-end; /* Aligns to the right */
            border-bottom-right-radius: 4px;
        }

        .message.received {
            background-color: #ffffff;
            color: #333;
            align-self: flex-start; /* Aligns to the left */
            border-bottom-left-radius: 4px;
        }

        .message.received .message-timestamp {
            color: rgba(0, 0, 0, 0.5);
        }

        /* --- Typing Indicator --- */
        .typing-indicator {
            padding: 0 20px 10px 20px;
            height: 25px; /* Reserve space to prevent layout shift */
            display: none; /* Hidden by default */
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .typing-indicator.visible {
            display: block;
            opacity: 1;
        }

        .typing-indicator span {
            height: 8px;
            width: 8px;
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            display: inline-block;
            margin: 0 2px;
            animation: bounce 1.4s infinite ease-in-out both;
        }

        .typing-indicator span:nth-child(2) { animation-delay: -0.32s; }
        .typing-indicator span:nth-child(3) { animation-delay: -0.16s; }

        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1.0); }
        }

        /* Animation for new messages */
        @keyframes fadeInMessage {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* --- New Selection Screen & Login Modal Styles --- */
        .hidden {
            display: none !important;
        }

        .selection-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            gap: 20px;
            position: relative; /* Ensure content is above the emojis */
        }

        .user-selection-box {
            position: relative; /* For notification badge positioning */
            width: 300px;
            height: 150px;
            background: rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(10px);
            border-radius: 25px;
            border: 1px solid rgba(255, 255, 255, 0.18);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: 600;
            color: white;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .user-selection-box:hover {
            transform: translateY(-10px);
            box-shadow: 0 12px 40px 0 rgba(31, 38, 135, 0.25);
        }

        .notification-badge {
            position: absolute;
            top: 15px;
            right: 20px;
            width: 25px;
            height: 25px;
            background-color: #ff4d4d;
            color: white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9rem;
            font-weight: 600;
            box-shadow: 0 0 10px rgba(255, 77, 77, 0.7);
        }
        .login-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .login-modal-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .login-box {
            background: #fff;
            padding: 30px 40px;
            border-radius: 15px;
            text-align: center;
            color: #333;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .login-box h2 {
            margin-bottom: 10px;
            color: #d6336c;
        }

        .login-box p {
            margin-bottom: 20px;
        }

        .login-box input {
            width: 100%;
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 8px;
        }

        .error-message {
            color: #d9480f;
            font-size: 0.9rem;
            height: 1.2em;
        }

        .user-selection-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .user-selection-box .status-indicator {
            font-size: 0.9rem;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.8);
        }

        .user-selection-box .status-indicator .status-dot {
            background-color: #ff6b6b; /* A softer red for offline */
        }

        .user-selection-box .status-indicator.online .status-dot {
            background-color: #2ecc71; /* Green for online */
        }
        
        @keyframes pulseRecording {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }


        .switch-user-button {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            background: none; border: none; font-size: 1.5rem; color: #d6336c; cursor: pointer;
        }

        .header-icons {
            display: flex;
            gap: 15px;
        }

        .clear-history-button, .switch-user-button, .refresh-chat-button {
            position: static;
            transform: none;
            background: none; border: none; font-size: 1.5rem; color: #d6336c; cursor: pointer; transition: transform 0.2s;
        }

        .call-button {
            position: static;
            transform: none;
            background: none;
            border: none;
            font-size: 1.4rem; /* Slightly smaller than other icons */
            color: #d6336c;
            cursor: pointer;
            transition: transform 0.2s;
            padding: 0 5px; /* Add some spacing */
        }

        .clear-history-button:hover,
        .switch-user-button:hover,
        .refresh-chat-button:hover,
        .call-button:hover {
            transform: scale(1.15);
        }
        /* --- Main Page Header --- */
        .main-header {
            font-size: 2.8rem;
            font-weight: 600;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 105, 180, 0.7), 0 0 20px rgba(255, 105, 180, 0.5);
            animation: pulseHeader 2.5s infinite ease-in-out;
            text-align: center;
        }

        @keyframes pulseHeader {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }

        /* --- Image Zoom Modal --- */
        .image-zoom-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .image-zoom-modal-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        #zoomed-image {
            max-width: 90vw;
            max-height: 90vh;
            object-fit: contain;
            border-radius: 10px;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }

        .close-zoom-button {
            position: absolute;
            top: 20px;
            right: 35px;
            color: #fff;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s;
        }

        .refresh-chat-button {
            position: static;
            transform: none;
            background: none; border: none; font-size: 1.5rem; color: #d6336c; cursor: pointer; transition: transform 0.2s;
        }

        /* --- Responsive Design --- */
        @media (max-width: 768px) {
            /* Adjust selection screen for mobile */
            .selection-container {
                flex-direction: column;
                gap: 20px;
            }
            .main-header {
                font-size: 1.9rem;
            }

            .user-selection-box {
                width: 80vw;
                max-width: 320px;
                height: 120px;
                font-size: 1.3rem;
            }

            /* Make chat view full-screen on mobile */
            .chat-app-container {
                width: 100%;
                height: 100%;
                padding: 0;
                display: block; /* Override the desktop flex layout */
            }

            .chat-box {
                height: 100vh;
                max-height: none;
                border-radius: 0;
                border: none;
            }

            .chat-header {
                border-radius: 0;
            }

            .chat-input-area {
                padding: 10px; /* Reduce padding on mobile */
                align-items: center; /* Vertically align items */
            }

            .message {
                max-width: 85%;
            }

            /* --- Mobile-specific size adjustments --- */
            .chat-header {
                padding: 15px;
                font-size: 1rem;
            }
            .message-image, .message-video {
                max-height: 200px; /* Reduce max height for attachments */
            }
            .chat-input {
                font-size: 0.9rem;
            }
            .attach-button, .camera-button, .voice-record-button, .send-icon-button {
                font-size: 1.3rem; /* Slightly smaller icons */
                padding: 0 8px;
            }
            .call-avatar {
                width: 120px;
                height: 120px;
                font-size: 4rem;
            }
            .call-info h2 { font-size: 1.5rem; }
            .call-info p { font-size: 1rem; }
        }

        /* --- Image Zoom Modal --- */
        .image-zoom-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .image-zoom-modal-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        #zoomed-image {
            max-width: 90vw;
            max-height: 90vh;
            object-fit: contain;
            border-radius: 10px;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }

        .close-zoom-button {
            position: absolute;
            top: 20px;
            right: 35px;
            color: #fff;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s;
        }

        /* --- Camera Preview Modal --- */
        .camera-preview-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 3000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #camera-stream {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        #camera-stream.mirrored {
            transform: scaleX(-1); /* Flip horizontally for a mirror effect */
        }
        #photo-preview {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Use contain to see the whole picture */
            background-color: #000;
        }
        #attachment-preview-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background-color: #000;
        }
        #attachment-preview-video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            background-color: #000;
        }

        .camera-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(to top, rgba(0,0,0,0.5), transparent);
        }

        .camera-top-controls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 30px;
            display: flex;
            justify-content: flex-end; /* Align to the right */
            align-items: center;
            background: linear-gradient(to bottom, rgba(0,0,0,0.5), transparent);
            z-index: 1; /* Ensure it's above the video stream */
        }


        .camera-control-btn {
            background: none;
            border: none;
            color: white;
            font-size: 2rem;
            cursor: pointer;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
            transition: transform 0.2s;
        }
        .camera-control-btn:hover {
            transform: scale(1.1);
        }
        .camera-control-btn.active {
            color: #f1c40f; /* Yellow color for active flash */
            text-shadow: 0 0 10px #f1c40f;
        }

        .capture-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.9);
            border: 5px solid rgba(0,0,0,0.3);
            box-shadow: 0 0 15px rgba(0,0,0,0.3);
        }
        .camera-control-placeholder { width: 40px; } /* To balance the close button */
        #send-photo-btn {
            background-color: #d6336c;
            color: white;
            padding: 12px 25px;
            border-radius: 30px;
            font-size: 1.2rem;
            font-weight: 600;
            text-shadow: none;
        }

        /* --- Call Modal Styles --- */
        .call-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(15px);
            z-index: 4000;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            flex-direction: column; /* Ensure vertical layout */
        }

        .call-header {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 30px 20px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.4), transparent);
            z-index: 5;
            text-align: center;
        }


        .call-header.hidden-on-audio-call {
            /* This class will be used to hide the header during outgoing/incoming audio calls */
            display: none;
        }

        .call-header #call-timer {
            font-size: 1rem;
            font-weight: 300;
            margin-top: 5px;
        }

        .call-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column; /* This will be overridden for video */
            justify-content: center; /* Center the main content */
            align-items: center;
        }
        .call-container.audio-active-view {
            justify-content: space-around; /* Better spacing for audio call view */
        }

        .call-avatar {
            width: 150px;
            height: 150px;
            background-color: rgba(255, 255, 255, 0.15);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 5rem;
            font-weight: 600;
            color: white;
            text-shadow: 0 0 10px rgba(0,0,0,0.3);
            border: 3px solid rgba(255, 255, 255, 0.3);
        }
        
        /* Styles for the large avatar in an active audio call */
        .call-container.audio-active-view #call-avatar {
            width: 180px;
            height: 180px;
            font-size: 6rem;
            border-width: 4px;
            border-color: #d6336c;
            box-shadow: 0 0 30px rgba(214, 51, 108, 0.5);
            animation: pulseCallIcon 2s infinite ease-in-out;
        }



        .audio-call-visualizer {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 8rem;
            color: #d6336c;
            animation: pulseCallIcon 2s infinite ease-in-out;
        }

        @keyframes pulseCallIcon {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
        }

        #remote-video {
            width: 95vw; /* Use most of the viewport width */
            max-width: 800px; /* But not excessively large on desktop */
            height: auto;
            max-height: 80vh; /* Limit height to leave space for controls */
            object-fit: contain; /* Ensure the whole video is visible without cropping */
            border-radius: 15px;
            border: 4px solid #d6336c; /* The requested appropriate border */
            box-shadow: 0 0 40px rgba(214, 51, 108, 0.5); /* Add a glow effect */
            background-color: #111; /* Dark background for letterboxing/loading */
            z-index: 2; /* Ensure it's above the background but below controls */
            transform: scaleX(-1); /* Flip horizontally for a mirror effect */
        }
        #remote-video { transition: all 0.3s ease; }

        #local-video {
            /* Hide self-view as requested for a cleaner look */
            display: none !important;
        }

        .call-info {
            position: static;
            flex-shrink: 0; /* Prevent it from shrinking */
            background: none; /* Reset background */
            padding: 0;
            text-align: center;
        }

        .call-info h2 {
            font-size: 1.8rem; /* Larger font for name */
            font-weight: 600;
        }
        .call-container.audio-active-view .call-info h2,
        .call-container.audio-active-view .call-info p {
            display: none; /* Hide the h2 and p inside the centered avatar container */
        }

        .call-info p {
            font-size: 1.2rem;
            animation: pulseHeader 2s infinite;
        }

        .call-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            padding: 40px 30px;
            background: linear-gradient(to top, rgba(0,0,0,0.4), transparent);
            z-index: 5;
        }

        .call-control-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 1.8rem;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s;
        }
        .call-control-btn:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }
        .call-control-btn.end-call { background-color: #e74c3c; }
        .call-control-btn.end-call:hover { background-color: #c0392b; }
        .call-control-btn.accept-call { background-color: #2ecc71; }
        .call-control-btn.accept-call:hover { background-color: #27ae60; }

        .incoming-call-actions {
            display: flex;
            gap: 60px; /* More space between accept/reject */
            align-items: center;
        }

        /* New container to group all active call buttons for single-line layout */
        .active-call-controls {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: center;
        }

        .call-control-btn.active { background-color: #d6336c; }


        /* --- Immersive Video Call View --- */
        .call-modal-overlay.immersive-view .call-header,
        .call-modal-overlay.immersive-view .call-controls {
            opacity: 0;
            pointer-events: none;
        }

        .call-modal-overlay.immersive-view #remote-video {
            width: 100vw;
            height: 100vh;
            max-width: none;
            max-height: none;
            border-radius: 0;
            border: none;
            object-fit: contain; /* Fills the screen without cropping, may add letterboxing */
        }

        /* --- Voice Chat Modal --- */
        .voice-chat-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            z-index: 5000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
        }

        .voice-chat-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 30px;
        }

        .voice-chat-icon {
            font-size: 8rem;
            color: #2ecc71; /* Green to indicate live connection */
            animation: pulseCallIcon 2s infinite ease-in-out;
        }

        .voice-chat-info h2 {
            font-size: 1.8rem;
            font-weight: 600;
        }

        .voice-chat-controls {
            position: absolute;
            bottom: 50px;
        }

        /* --- Sound Alert Modal --- */
        .alert-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 0, 0, 0.5); /* Semi-transparent red */
            backdrop-filter: blur(10px);
            z-index: 6000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
            animation: pulseRedBackground 1s infinite;
        }

        .alert-modal-content h2 {
            font-size: 2.5rem;
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
            margin-bottom: 30px;
        }

        .alert-modal-content .call-control-btn {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
        }

        @keyframes pulseRedBackground {
            0%, 100% { background-color: rgba(200, 0, 0, 0.6); }
            50% { background-color: rgba(255, 50, 50, 0.7); }
        }


    </style>
</head>
<body>

    <!-- Container for the animated hearts -->
    <div class="background-slideshow"></div>

    <!-- Initial selection screen -->
    <div class="selection-container" id="selection-container">
        <div class="login-box" style="background: rgba(255, 255, 255, 0.25); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.18); padding: 40px;">
            <h3 style="font-size: 2rem; color: rgb(12, 25, 212); text-shadow: 1px 1px 3px rgba(0,0,0,0.3); margin-bottom: 15px;">Welcome to NDA</h3>
            <img src="data:image/jpeg;base64,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" alt="NDA Logo" style="width: 100px; height: auto; margin-bottom: 20px;">
            <h3 style="color: white; text-shadow: 1px 1px 3px rgba(0,0,0,0.2); margin-bottom: 20px;">Admin Login</h3>
            <form id="admin-login-form">
                <input type="text" id="username-input" placeholder="User ID" required style="background: rgba(255, 255, 255, 0.5); color: #333;">
                <input type="password" id="password-input" placeholder="Password" required style="background: rgba(255, 255, 255, 0.5); color: #333;">
                <p class="error-message" id="login-error-message">&nbsp;</p>
                <button type="submit" class="send-icon-button" style="background: #d6336c; color: white; border-radius: 20px; padding: 10px 20px; font-size: 1rem; font-weight: 600;">Login</button>
            </form>
        </div>
    </div>

    <!-- Image Zoom Modal -->
    <div id="image-zoom-modal" class="image-zoom-modal-overlay hidden">
        <span class="close-zoom-button">&times;</span>
        <img id="zoomed-image" src="" alt="Zoomed Image">
    </div>

    <!-- Attachment Preview Modal -->
    <div id="attachment-preview-modal" class="camera-preview-overlay hidden">
        <img id="attachment-preview-image" class="hidden" src="" alt="Attachment Preview">
        <video id="attachment-preview-video" class="hidden" controls src=""></video>
        <div id="attachment-preview-controls" class="camera-controls">
            <button id="close-attachment-preview" class="camera-control-btn" title="Close">‚ùå</button>
            <button id="send-attachment-btn" class="camera-control-btn" title="Send">Send ‚û§</button>
            <button id="reattach-file-btn" class="camera-control-btn" title="Change File">üîÑ</button>
        </div>
    </div>


    <!-- Camera Preview Modal -->
    <div id="camera-preview-modal" class="camera-preview-overlay hidden">
        <div id="live-camera-top-controls" class="camera-top-controls">
            <button id="toggle-flash-btn" class="camera-control-btn" title="Toggle Flash">‚ö°</button>
        </div>
        <video id="camera-stream" autoplay playsinline></video>
        <img id="photo-preview" class="hidden" src="" alt="Captured Photo">
        <div id="live-camera-controls" class="camera-controls">
            <button id="close-camera-preview" class="camera-control-btn" title="Close">‚ùå</button>
            <button id="capture-photo-btn" class="camera-control-btn capture-btn" title="Capture Photo"></button>
            <button id="flip-camera-btn" class="camera-control-btn" title="Flip Camera">üîÑ</button>
        </div>
        <div id="preview-controls" class="camera-controls hidden">
            <button id="retake-photo-btn" class="camera-control-btn" title="Retake">üîÑ Retake</button>
            <button id="send-photo-btn" class="camera-control-btn" title="Send">Send ‚û§</button>
        </div>
    </div>

    <!-- Voice Chat Modal -->
    <div id="voice-chat-modal" class="voice-chat-modal-overlay hidden">
        <div class="voice-chat-container">
            <div class="voice-chat-icon">üéôÔ∏è</div>
            <div class="voice-chat-info">
                <h2>Live Voice Chat</h2>
            </div>
        </div>
        <div class="voice-chat-controls">
            <button id="end-voice-chat-btn" class="call-control-btn end-call" title="End Voice Chat">üìû</button>
        </div>
    </div>

    <!-- Sound Alert Modal -->
    <div id="sound-alert-modal" class="alert-modal-overlay hidden">
        <div class="alert-modal-content">
            <h2 id="sound-alert-message"></h2>
            <button id="stop-alert-btn" class="call-control-btn end-call" title="Stop Alert">STOP</button>
        </div>
    </div>

    <!-- Call Modal -->
    <div id="call-modal" class="call-modal-overlay hidden">
        <div class="call-header">
            <div id="call-status-info" class="call-info">
                <h2 id="call-with-user-header"></h2>
                <p id="call-timer" class="hidden"></p>
                <p id="call-status-text-header"></p>
            </div>
        </div>
        <div class="call-container">
            <div id="audio-call-info-container" class="call-info hidden">
                <div id="call-avatar" class="call-avatar"></div>
                <h2 id="call-with-user-main"></h2>
                <p id="call-status-text-main"></p>
            </div>
            <video id="remote-video" autoplay playsinline></video>
            <video id="local-video" autoplay playsinline muted></video>

            <div id="audio-call-visualizer" class="audio-call-visualizer hidden">
                üìû
            </div>
            <div id="call-controls" class="call-controls">
                <div id="active-call-actions" class="active-call-controls hidden">
                    <button id="toggle-mic-btn" class="call-control-btn" title="Mute/Unmute Mic">üé§</button>
                    <button id="toggle-video-btn" class="call-control-btn" title="Toggle Video">üìπ</button>
                    <button id="toggle-speaker-btn" class="call-control-btn" title="Toggle Speaker">üîä</button>
                    <button id="flip-camera-call-btn" class="call-control-btn" title="Flip Camera">üîÑ</button>
                    <button id="end-call-btn" class="call-control-btn end-call" title="End Call">üìû</button>
                </div>
                <div id="incoming-call-actions" class="incoming-call-actions hidden">
                    <button id="accept-call-btn" class="call-control-btn accept-call" title="Accept Call">üìû</button>
                    <button id="end-call-btn-decline" class="call-control-btn end-call" title="Decline Call">üìû</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Main container for the two chat boxes -->
    <div class="chat-app-container hidden" id="chat-app-container">

        <!-- Raushan's Chat Box -->
        <div class="chat-box" id="raushan-chat">
            <div class="chat-header">
                <div class="user-info">
                    <span>‚ù§Ô∏è Raushan_143 ‚ù§Ô∏è</span>
                    <div class="status-indicator" id="nisha-status">
                        <span class="status-dot"></span>
                        <span class="status-text">Offline</span>
                    </div>
                </div>
                <div class="header-menu">
                    <button class="menu-toggle-button" title="Menu"><span></span><span></span><span></span></button>                    <div class="menu-dropdown"> <!-- Removed 'hidden' class, now controlled by 'visible' -->
                        <button class="voice-chat-button" data-user="raushan" title="Start Voice Chat">üéôÔ∏è Voice Chat</button>
                        <button class="sound-alert-button" data-user="raushan" title="Send Sound Alert">üö® Sound Alert</button>
                        <button class="call-button" data-user="raushan" data-call-type="video" title="Video Call">üìπ Video Call</button>
                        <button class="call-button" data-user="raushan" data-call-type="audio" title="Audio Call">üìû Audio Call</button>
                        <button class="refresh-chat-button" title="Refresh Chat">üîÑ Refresh</button>
                        <button class="clear-history-button" title="Clear History">üóëÔ∏è Clear History</button>
                        <button class="switch-user-button" title="Switch User">‚Ü©Ô∏è Logout</button>
                    </div>
                </div>
            </div>
            <div class="chat-messages" id="raushan-messages">
                <!-- Messages will appear here -->
            </div>
            <div class="typing-indicator" id="raushan-typing-indicator">
                <span></span><span></span><span></span>
            </div>
            <form class="chat-input-area" id="raushan-form">
                <input type="file" id="raushan-file-input" class="hidden" accept="image/*,video/*">
                <button type="button" class="attach-button" data-user="raushan" title="Attach File">üìé</button>
                <button type="button" class="camera-button" data-user="raushan" title="Use Camera">üì∏</button>
                <button type="button" class="voice-record-button" data-user="raushan" title="Record Voice Message">üé§</button>
                <div class="audio-preview hidden" id="raushan-audio-preview">
                    <button type="button" class="delete-audio-button" title="Delete Recording">üóëÔ∏è</button>
                    <audio controls class="preview-audio-player"></audio>
                    <button type="button" class="send-icon-button send-audio-button" title="Send Audio">‚û§</button>
                </div>
                <input type="text" id="raushan-input" class="chat-input" placeholder="Type a message...">
                <button type="submit" class="send-icon-button" title="Send">‚û§</button>
            </form>
        </div>

        <!-- Nisha's Chat Box -->
        <div class="chat-box" id="nisha-chat">
            <div class="chat-header">
                <div class="user-info">
                    <span>üíñ Nisha_143 üíñ</span>
                    <div class="status-indicator" id="raushan-status">
                        <span class="status-dot"></span>
                        <span class="status-text">Offline</span>
                    </div>
                </div>
                <div class="header-menu">
                    <button class="menu-toggle-button" title="Menu"><span></span><span></span><span></span></button>                    <div class="menu-dropdown"> <!-- Removed 'hidden' class, now controlled by 'visible' -->
                        <button class="voice-chat-button" data-user="nisha" title="Start Voice Chat">üéôÔ∏è Voice Chat</button>
                        <button class="sound-alert-button" data-user="nisha" title="Send Sound Alert">üö® Sound Alert</button>
                        <button class="call-button" data-user="nisha" data-call-type="video" title="Video Call">üìπ Video Call</button>
                        <button class="call-button" data-user="nisha" data-call-type="audio" title="Audio Call">üìû Audio Call</button>
                        <button class="refresh-chat-button" title="Refresh Chat">üîÑ Refresh</button>
                        <button class="clear-history-button" title="Clear History">üóëÔ∏è Clear History</button>
                        <button class="switch-user-button" title="Switch User">‚Ü©Ô∏è Logout</button>
                    </div>
                </div>
            </div>
            <div class="chat-messages" id="nisha-messages">
                <!-- Messages will appear here -->
            </div>
            <div class="typing-indicator" id="nisha-typing-indicator">
                <span></span><span></span><span></span>
            </div>
            <form class="chat-input-area" id="nisha-form">
                <input type="file" id="nisha-file-input" class="hidden" accept="image/*,video/*">
                <button type="button" class="attach-button" data-user="nisha" title="Attach File">üìé</button>
                <button type="button" class="camera-button" data-user="nisha" title="Use Camera">üì∏</button>
                <button type="button" class="voice-record-button" data-user="nisha" title="Record Voice Message">üé§</button>
                <div class="audio-preview hidden" id="nisha-audio-preview">
                    <button type="button" class="delete-audio-button" title="Delete Recording">üóëÔ∏è</button>
                    <audio controls class="preview-audio-player"></audio>
                    <button type="button" class="send-icon-button send-audio-button" title="Send Audio">‚û§</button>
                </div>
                <input type="text" id="nisha-input" class="chat-input" placeholder="Type a message...">
                <button type="submit" class="send-icon-button" title="Send">‚û§</button>
            </form>
        </div>

    </div>

    <!-- Audio element for notification sound -->
    <audio id="notification-sound" preload="auto">
        <!-- A simple, pleasant notification sound from a free source -->
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-correct-answer-tone-2870.wav" type="audio/wav">
    </audio>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Chat Functionality ---
            const raushanForm = document.getElementById('raushan-form');
            const raushanInput = document.getElementById('raushan-input');
            const raushanMessages = document.getElementById('raushan-messages');

            const nishaForm = document.getElementById('nisha-form');
            const nishaInput = document.getElementById('nisha-input');
            const nishaMessages = document.getElementById('nisha-messages');

            const raushanTypingIndicator = document.getElementById('raushan-typing-indicator');
            const nishaTypingIndicator = document.getElementById('nisha-typing-indicator');

            // New elements for login flow
            const selectionContainer = document.getElementById('selection-container');
            const chatAppContainer = document.getElementById('chat-app-container');
            const loginForm = document.getElementById('admin-login-form');
            const usernameInput = document.getElementById('username-input');
            const passwordInput = document.getElementById('password-input');
            const errorMessage = document.getElementById('login-error-message');

            const userSelectionBoxes = document.querySelectorAll('.user-selection-box');
            const switchUserButtons = document.querySelectorAll('.switch-user-button');
            const clearHistoryButtons = document.querySelectorAll('.clear-history-button'); // This was correct
            const refreshButtons = document.querySelectorAll('.refresh-chat-button');

            // New elements for image sending
            const attachButtons = document.querySelectorAll('.attach-button');
            const fileInputs = document.querySelectorAll('input[type="file"]');

            // New elements for image zoom
            const imageZoomModal = document.getElementById('image-zoom-modal');
            const zoomedImage = document.getElementById('zoomed-image');
            const closeZoomButton = document.querySelector('.close-zoom-button');

            // New elements for voice recording
            const voiceRecordButtons = document.querySelectorAll('.voice-record-button');
            const cameraButtons = document.querySelectorAll('.camera-button');

            // New elements for camera preview
            const cameraPreviewModal = document.getElementById('camera-preview-modal');
            const photoPreview = document.getElementById('photo-preview');
            const cameraStream = document.getElementById('camera-stream');
            const capturePhotoButton = document.getElementById('capture-photo-btn');
            const closeCameraPreviewButton = document.getElementById('close-camera-preview');
            const retakePhotoButton = document.getElementById('retake-photo-btn');
            const sendPhotoButton = document.getElementById('send-photo-btn');
            const flipCameraButton = document.getElementById('flip-camera-btn');
            const toggleFlashButton = document.getElementById('toggle-flash-btn');

            // New elements for attachment preview
            const attachmentPreviewModal = document.getElementById('attachment-preview-modal');
            const attachmentPreviewImage = document.getElementById('attachment-preview-image');
            const attachmentPreviewVideo = document.getElementById('attachment-preview-video');
            const closeAttachmentPreviewBtn = document.getElementById('close-attachment-preview');
            const sendAttachmentBtn = document.getElementById('send-attachment-btn');
            const reattachFileBtn = document.getElementById('reattach-file-btn');

            // New element for notification sound
            const notificationSound = document.getElementById('notification-sound');

            // New elements for WebRTC calls
            const callModal = document.getElementById('call-modal');
            const callButtons = document.querySelectorAll('.call-button');
            const localVideo = document.getElementById('local-video');
            const remoteVideo = document.getElementById('remote-video');
            const callWithUserHeaderEl = document.getElementById('call-with-user-header');
            const callStatusTextHeaderEl = document.getElementById('call-status-text-header');
            const callWithUserMainEl = document.getElementById('call-with-user-main');
            const callStatusTextMainEl = document.getElementById('call-status-text-main');
            const callAvatarEl = document.getElementById('call-avatar');
            const audioCallInfoContainer = document.getElementById('audio-call-info-container');
            const acceptCallBtn = document.getElementById('accept-call-btn');
            const callTimerEl = document.getElementById('call-timer');
            const endCallBtn = document.getElementById('end-call-btn');
            const toggleMicBtn = document.getElementById('toggle-mic-btn');
            const toggleVideoBtn = document.getElementById('toggle-video-btn');
            const toggleSpeakerBtn = document.getElementById('toggle-speaker-btn');
            const flipCameraCallBtn = document.getElementById('flip-camera-call-btn');
            let activeUser = null;
            // Voice Chat elements
            const voiceChatModal = document.getElementById('voice-chat-modal');
            const voiceChatButtons = document.querySelectorAll('.voice-chat-button');
            const endVoiceChatBtn = document.getElementById('end-voice-chat-btn');
            // Sound Alert elements
            const soundAlertButtons = document.querySelectorAll('.sound-alert-button');
            const soundAlertModal = document.getElementById('sound-alert-modal');
            const soundAlertMessage = document.getElementById('sound-alert-message');
            const stopAlertBtn = document.getElementById('stop-alert-btn');
            const alarmSound = new Audio('https://assets.mixkit.co/sfx/preview/mixkit-police-siren-us-1643.mp3'); // Switched to a more reliable source

            const USERS = {
                "Raushan_143": "asdf@1234",
                "Nisha_143": "11041805143"
            };
            let activeUserForAttachment = null;

            let raushanTypingTimer;
            let nishaTypingTimer;
            
            let socket;
            let unreadCountInterval;
            let initialStatusLoaded = false; // Flag to check if we've received initial statuses
            const messageElements = new Map(); // To map message ID to its DOM element

            // WebRTC state variables
            let peerConnection;
            let localStream;
            let isCallInProgress = false;
            let callOfferData = null;
            let callRecipient = null; // New variable to track the outgoing call recipient
            let outgoingCallType = null; // New variable to track the call type for the initiator
            let callTimerInterval = null;
            let voiceChatPeerConnection;
            let voiceChatStream;
            let callAnswerTimeout = null; // Timer for unanswered calls
            let callStartTime = null; // To track the start time of an active call
            let reconnectionTimer = null;
            const RECONNECTION_TIMEOUT = 3000; // 30 seconds to reconnect
            let currentCallFacingMode = 'user'; // 'user' for front, 'environment' for back
            const iceServers = {
                // It's recommended to use your own TURN server for production applications
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' } // Public STUN server
                ]
            };
            function formatSeenDate(isoString) {
                const date = new Date(isoString);
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0'); // Month is 0-indexed
                const year = date.getFullYear();
                return `${day}-${month}-${year}`;
            }

            // --- Sound Alert Logic ---
            let vibrationInterval;

            const handleSoundAlert = (fromUser) => {
                const senderName = fromUser.charAt(0).toUpperCase() + fromUser.slice(1);
                soundAlertMessage.textContent = `${senderName} is alerting you!`;
                soundAlertModal.classList.remove('hidden');

                // Play looping alarm sound. Reloading the sound can help bypass some browser restrictions.
                const playPromise = alarmSound.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        alarmSound.loop = true; // Start looping after it successfully plays once
                    }).catch(error => {
                        console.error("Could not play alarm sound:", error);
                        // As a fallback, we can try loading and playing again.
                        alarmSound.load();
                        alarmSound.play();
                    });
                }

                // Vibrate continuously (if supported)
                if ('vibrate' in navigator) {
                    // A pattern that feels continuous: vibrate 1s, pause 0.1s
                    vibrationInterval = setInterval(() => navigator.vibrate(1000), 1100);
                    navigator.vibrate(1000); // Vibrate immediately
                }
            };

            const stopSoundAlert = () => {
                soundAlertModal.classList.add('hidden');
                alarmSound.pause();
                alarmSound.currentTime = 0;
                alarmSound.loop = false;
                if (vibrationInterval) {
                    clearInterval(vibrationInterval);
                    vibrationInterval = null;
                    navigator.vibrate(0); // Stop any active vibration
                }
            };

            // --- Voice Chat Logic ---
            const startVoiceChat = async (recipient) => {
                if (isCallInProgress || voiceChatPeerConnection) {
                    alert("You are already in a call or voice chat.");
                    return;
                }
                try {
                    voiceChatStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                    voiceChatModal.classList.remove('hidden');

                    voiceChatPeerConnection = new RTCPeerConnection(iceServers);
                    voiceChatStream.getTracks().forEach(track => voiceChatPeerConnection.addTrack(track, voiceChatStream));

                    voiceChatPeerConnection.ontrack = event => {
                        const remoteAudio = new Audio();
                        remoteAudio.srcObject = event.streams[0];
                        remoteAudio.play();
                    };

                    voiceChatPeerConnection.onicecandidate = event => {
                        if (event.candidate) {
                            socket.send(JSON.stringify({ type: 'voice-chat-ice-candidate', payload: { to: recipient, candidate: event.candidate } }));
                        }
                    };

                    const offer = await voiceChatPeerConnection.createOffer();
                    await voiceChatPeerConnection.setLocalDescription(offer);

                    socket.send(JSON.stringify({ type: 'voice-chat-offer', payload: { from: activeUser, to: recipient, offer: offer } }));
                } catch (err) {
                    console.error("Error starting voice chat:", err);
                    alert("Could not start voice chat. Please check microphone permissions.");
                    endVoiceChat();
                }
            };

            const handleVoiceChatOffer = async (data) => {
                if (isCallInProgress || voiceChatPeerConnection) return; // Already busy

                try {
                    voiceChatStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                    voiceChatModal.classList.remove('hidden');

                    voiceChatPeerConnection = new RTCPeerConnection(iceServers);
                    voiceChatStream.getTracks().forEach(track => voiceChatPeerConnection.addTrack(track, voiceChatStream));

                    voiceChatPeerConnection.ontrack = event => {
                        const remoteAudio = new Audio();
                        remoteAudio.srcObject = event.streams[0];
                        remoteAudio.play();
                    };

                    voiceChatPeerConnection.onicecandidate = event => {
                        if (event.candidate) {
                            socket.send(JSON.stringify({ type: 'voice-chat-ice-candidate', payload: { to: data.from, candidate: event.candidate } }));
                        }
                    };

                    await voiceChatPeerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
                    const answer = await voiceChatPeerConnection.createAnswer();
                    await voiceChatPeerConnection.setLocalDescription(answer);

                    socket.send(JSON.stringify({ type: 'voice-chat-answer', payload: { from: activeUser, to: data.from, answer: answer } }));
                } catch (err) {
                    console.error("Error handling voice chat offer:", err);
                    endVoiceChat();
                }
            };

            const handleVoiceChatAnswer = async (data) => {
                if (voiceChatPeerConnection) {
                    await voiceChatPeerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                }
            };

            const handleVoiceChatICECandidate = (data) => {
                if (voiceChatPeerConnection) {
                    voiceChatPeerConnection.addIceCandidate(new RTCIceCandidate(data.candidate)).catch(e => console.error("Error adding voice chat ICE candidate", e));
                }
            };

            const endVoiceChat = () => {
                if (voiceChatStream) voiceChatStream.getTracks().forEach(track => track.stop());
                if (voiceChatPeerConnection) voiceChatPeerConnection.close();
                voiceChatStream = null;
                voiceChatPeerConnection = null;
                voiceChatModal.classList.add('hidden');
                // Notify other user
                const recipient = activeUser === 'raushan' ? 'nisha' : 'raushan';
                socket.send(JSON.stringify({ type: 'voice-chat-end', payload: { to: recipient } }));
            };
            function formatSeenTime(isoString) {
                if (!isoString) return '';
                const date = new Date(isoString);
                // HH:MM:SS format
                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
            }

            // --- WebRTC Call Logic ---

            const startCall = async (callType, recipient) => {
                if (isCallInProgress) {
                    alert("A call is already in progress.");
                    return;
                }

                callRecipient = recipient; // Store the recipient for the outgoing call
                outgoingCallType = callType; // Store the call type for the initiator
                currentCallFacingMode = 'user'; // Reset to front camera for new calls
                try {
                    const constraints = {
                        video: callType === 'video',
                        audio: true
                    };
                    localStream = await navigator.mediaDevices.getUserMedia(constraints);
                    localVideo.srcObject = localStream;
                    isCallInProgress = true;

                    setupPeerConnection(recipient);

                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);

                    socket.send(JSON.stringify({
                        type: 'call-offer',
                        payload: {
                            from: activeUser,
                            to: recipient,
                            offer: offer,
                            callType: callType
                        }
                    }));

                    // Set a timeout for the call to be answered
                    callAnswerTimeout = setTimeout(() => {
                        console.log("Call not answered within 10 seconds. Ending call and logging as missed.");
                        
                        // 1. End the call UI for the caller and notify the recipient to stop ringing.
                        endCall(true); 

                        // 2. Create and send a "missed call" message.
                        const missedCallMessageData = {
                            sender: activeUser,
                            recipient: recipient,
                            content: {
                                type: 'missed_call',
                                callType: callType
                            },
                            timeString: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                        };
                        fetch('/api/messages', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(missedCallMessageData) });

                    }, 10000); // 10-second timeout

                    showCallModal('outgoing', recipient, callType);
                } catch (err) {
                    console.error("Error starting call:", err);
                    alert("Could not start call. Please check camera/microphone permissions.");
                    isCallInProgress = false;
                }
            };

            const handleIncomingCall = (data) => {
                if (isCallInProgress) {
                    // User is busy, reject the call
                    socket.send(JSON.stringify({ type: 'user-busy', payload: { from: activeUser, to: data.from } }));
                    return;
                }

                callOfferData = data; // Store the offer
                isCallInProgress = true;
                showCallModal('incoming', data.from, data.callType);
            };

            const acceptCall = async () => {
                if (!callOfferData) return;

                try {
                    const constraints = {
                        video: callOfferData.callType === 'video',
                        audio: true
                    };
                    localStream = await navigator.mediaDevices.getUserMedia(constraints);
                    localVideo.srcObject = localStream;

                    setupPeerConnection(callOfferData.from);

                    await peerConnection.setRemoteDescription(new RTCSessionDescription(callOfferData.offer));

                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);

                    socket.send(JSON.stringify({
                        type: 'call-answer',
                        payload: {
                            from: activeUser,
                            to: callOfferData.from,
                            answer: answer
                        }
                    }));

                    showCallModal('active', callOfferData.from, callOfferData.callType);
                } catch (err) {
                    console.error("Error accepting call:", err);
                    endCall(true);
                }
            };

            const handleCallAnswer = async (data) => {
                if (peerConnection) {
                    // The call was answered, so clear the timeout timer.
                    clearTimeout(callAnswerTimeout);
                    callAnswerTimeout = null;

                    // The user who initiated the call receives the answer
                    const callType = outgoingCallType; // Use the stored call type for the initiator
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                    
                    // This is the key fix: Update the UI to the 'active' state for the sender
                    showCallModal('active', callRecipient, callType); // Now uses the correct callType
                }
            };

            const handleNewICECandidate = (data) => {
                if (peerConnection) {
                    const candidate = new RTCIceCandidate(data.candidate);
                    peerConnection.addIceCandidate(candidate).catch(e => console.error("Error adding received ICE candidate", e));
                }
            };

            const setupPeerConnection = (recipient) => {
                peerConnection = new RTCPeerConnection(iceServers);

                // Add local stream tracks to the connection
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });

                // Handle incoming remote stream
                peerConnection.ontrack = event => {
                    remoteVideo.srcObject = event.streams[0];
                };

                // Handle ICE candidates
                peerConnection.onicecandidate = event => {
                    if (event.candidate) {
                        socket.send(JSON.stringify({
                            type: 'ice-candidate',
                            payload: {
                                to: recipient,
                                candidate: event.candidate
                            }
                        }));
                    }
                };

                peerConnection.oniceconnectionstatechange = () => {
                    console.log(`ICE connection state changed to: ${peerConnection.iceConnectionState}`);
                    switch (peerConnection.iceConnectionState) {
                        case 'disconnected':
                            // Connection lost, but might be recoverable. Start a timer.
                            callStatusTextHeaderEl.textContent = 'Connecting...';
                            if (!reconnectionTimer) {
                                reconnectionTimer = setTimeout(() => {
                                    console.log("Reconnection timeout. Ending call.");
                                    endCall(true); // End call if not reconnected within the timeout
                                }, RECONNECTION_TIMEOUT);
                            }
                            break;
                        case 'connected':
                        case 'completed':
                            // Connection re-established.
                            callStatusTextHeaderEl.textContent = ''; // Clear "Connecting..."
                            clearTimeout(reconnectionTimer);
                            reconnectionTimer = null;
                            break;
                        case 'failed':
                        case 'closed':
                            // Connection permanently lost.
                            endCall(false);
                            break;
                    }
                };
            };

            const endCall = (isInitiator) => {
                if (!isCallInProgress) return;

                // If the initiator hangs up before the call is answered, log it as a missed call.
                // We can check this by seeing if the callAnswerTimeout is still active.
                if (isInitiator && callAnswerTimeout) {
                    console.log("Caller hung up before answer. Logging as missed call.");
                    const callType = outgoingCallType || callOfferData?.callType;
                    const recipient = callOfferData?.from || callRecipient;

                    if (callType && recipient) {
                        const missedCallMessageData = {
                            sender: activeUser,
                            recipient: recipient,
                            content: {
                                type: 'missed_call',
                                callType: callType
                            },
                            timeString: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                        };
                        fetch('/api/messages', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(missedCallMessageData) });
                    }
                }

                // If the call was active, calculate duration and post a message
                if (callStartTime) {
                    const callEndTime = new Date();
                    const durationInSeconds = Math.round((callEndTime - callStartTime) / 1000);

                    // Only log a message for calls longer than a second to avoid accidental clicks
                    if (durationInSeconds > 1) {
                        const callType = outgoingCallType || callOfferData?.callType;
                        const recipient = callOfferData?.from || callRecipient;

                        // Create a "call_ended" message and send it to the server to be saved and broadcast
                        const messageData = {
                            sender: activeUser,
                            recipient: recipient,
                            content: {
                                type: 'call_ended',
                                callType: callType,
                                duration: durationInSeconds
                            },
                            timeString: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                        };
                        fetch('/api/messages', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(messageData) });
                    }
                }

                clearTimeout(reconnectionTimer);
                clearTimeout(callAnswerTimeout); // Also clear the answer timeout

                reconnectionTimer = null;
                callAnswerTimeout = null;

                if (isInitiator && socket && socket.readyState === WebSocket.OPEN) {
                    // Determine recipient: from incoming offer, or from our stored outgoing recipient
                    const recipient = callOfferData?.from || callRecipient;
                    if (recipient) {
                        socket.send(JSON.stringify({ type: 'call-end', payload: { to: recipient } }));
                    } else {
                        // Fallback if something went wrong, broadcast to end any stray call
                        socket.send(JSON.stringify({ type: 'call-end', payload: { to: activeUser === 'raushan' ? 'nisha' : 'raushan' } }));
                    }
                }

                if (peerConnection) {
                    peerConnection.close();
                    peerConnection = null;
                }
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                }

                localVideo.srcObject = null;
                remoteVideo.srcObject = null;
                callModal.classList.add('hidden');
                isCallInProgress = false;
                callOfferData = null;
                callRecipient = null; // Clear the recipient on call end
                outgoingCallType = null; // Clear the outgoing call type
            };

            remoteVideo.addEventListener('click', () => {
                // Only allow toggling immersive view during an active video call
                if (isCallInProgress && remoteVideo.srcObject) {
                    callModal.classList.toggle('immersive-view');
                }
            });
            const startCallTimer = () => {
                let seconds = 0;
                callTimerEl.textContent = '0:00';
                callTimerInterval = setInterval(() => {
                    seconds++;
                    callTimerEl.textContent = `${Math.floor(seconds / 60)}:${String(seconds % 60).padStart(2, '0')}`;
                }, 1000);
            };

            const showCallModal = (state, user, callType) => {
                callModal.classList.remove('hidden');
                const callContainer = callModal.querySelector('.call-container');
                const callHeader = callModal.querySelector('.call-header');
                const otherUser = user.charAt(0).toUpperCase() + user.slice(1);

                // Get the DOM elements for the main call info (avatar view)
                const mainCallInfoContainer = document.getElementById('audio-call-info-container');
                const mainCallAvatar = document.getElementById('call-avatar');
                const mainCallWithUser = document.getElementById('call-with-user-main');
                const mainCallStatus = document.getElementById('call-status-text-main');
                const activeCallActions = document.getElementById('active-call-actions'); // Contains all active call buttons
                const incomingCallActions = document.getElementById('incoming-call-actions'); // Contains accept/decline
                const audioVisualizer = document.getElementById('audio-call-visualizer'); // The phone icon
                const endCallBtnDecline = document.getElementById('end-call-btn-decline'); // The decline button for incoming calls

                incomingCallActions.classList.toggle('hidden', state !== 'incoming');
                endCallBtnDecline.onclick = () => endCall(true);

                // Stop any existing timer
                clearInterval(callTimerInterval);
                callStatusTextHeaderEl.classList.remove('hidden');
                callTimerEl.classList.add('hidden');

                const isVideoCall = callType === 'video';
                
                // Add a class to the overlay for video-specific styling
                callModal.classList.toggle('audio-active', !isVideoCall && state === 'active');
                callModal.classList.toggle('video-outgoing', isVideoCall && state === 'outgoing');
                callModal.classList.toggle('video-active', isVideoCall && (state === 'active' || state === 'outgoing'));

                // --- UI State Management ---
                callHeader.classList.toggle('hidden-on-audio-call', !isVideoCall && state === 'incoming');
                callContainer.classList.toggle('audio-active-view', !isVideoCall && (state === 'active' || state === 'outgoing'));
                // Hide the avatar container ONLY for active video calls, not incoming/outgoing ones.
                audioVisualizer.classList.add('hidden'); // Hide phone icon by default

                if (isVideoCall) {
                    mainCallInfoContainer.classList.toggle('hidden', state === 'active');
                    remoteVideo.classList.toggle('hidden', state !== 'active');
                } else {
                    mainCallInfoContainer.classList.remove('hidden'); // Always show avatar container for audio calls
                    remoteVideo.classList.add('hidden'); // Always hide video for audio calls
                }
                
                if (state === 'incoming') {
                    // Incoming call state: Show avatar, "Incoming call...", and accept/decline buttons.
                    callAvatarEl.textContent = otherUser.charAt(0);
                    callWithUserHeaderEl.textContent = ''; // Clear header text
                    callWithUserMainEl.textContent = `${otherUser}`;
                    callStatusTextMainEl.textContent = `Incoming ${callType} call...`;
                    activeCallActions.classList.add('hidden');
                    incomingCallActions.classList.remove('hidden');
                } else if (state === 'outgoing') {
                    // Outgoing call state:
                    incomingCallActions.classList.add('hidden');
                    activeCallActions.classList.remove('hidden');

                    // Set the header text based on the call type.
                    const callActionText = isVideoCall ? "Video Calling to" : "Audio Calling to"; // This was correct
                    callWithUserHeaderEl.textContent = `${callActionText} ${otherUser}`;
                    callStatusTextHeaderEl.textContent = ''; // Clear any previous status from the header

                    // Show the avatar and status for both audio and video outgoing calls.
                    mainCallInfoContainer.classList.remove('hidden');
                    mainCallAvatar.textContent = otherUser.charAt(0);
                    mainCallWithUser.textContent = ''; // The name is now in the header

                    // Check if the other user is online to show "Ringing..." vs "Calling..."
                    const otherUserStatusIndicator = document.getElementById(`${user}-status`);
                    mainCallStatus.textContent = (otherUserStatusIndicator && otherUserStatusIndicator.classList.contains('online'))
                        ? `Ringing...`
                        : `Calling...`;

                    // Set visibility for all active call buttons based on call type
                    flipCameraCallBtn.style.display = isVideoCall ? 'flex' : 'none';
                    toggleVideoBtn.style.display = 'none'; // Hide this button as requested
                    toggleMicBtn.style.display = 'flex';
                    toggleSpeakerBtn.style.display = 'flex';
                    endCallBtn.style.display = 'flex';
                } else { // active call state
                    incomingCallActions.classList.add('hidden');
                    activeCallActions.classList.remove('hidden');

                    // For active audio calls, ensure the avatar is visible and shows the correct initial
                    mainCallAvatar.textContent = otherUser.charAt(0); // This was correct
                    // Ensure the pulsing phone icon is hidden once the call is active
                    audioVisualizer.classList.add('hidden');

                    // For both active audio and video calls, start the timer.
                    // This block now handles the final UI state for an active call for BOTH users.
                    callWithUserHeaderEl.textContent = isVideoCall ? `Video Call With ${otherUser}` : `Audio Call with ${otherUser}`;
                    callStatusTextHeaderEl.textContent = ''; // Clear "Ringing..." or "Connected"
                    mainCallWithUser.textContent = ''; // Hide the centered name
                    mainCallStatus.textContent = ''; // Hide the centered status text
                    
                    // Show the timer
                    callTimerEl.classList.remove('hidden'); // Show the timer element
                    startCallTimer();

                    // Set visibility for all active call buttons
                    flipCameraCallBtn.classList.toggle('hidden', !isVideoCall);
                    toggleVideoBtn.style.display = 'none'; // Hide this button as requested
                    toggleMicBtn.style.display = 'flex';
                    toggleSpeakerBtn.style.display = 'flex';
                    endCallBtn.style.display = 'flex';
                }
            };

            // --- Event Listeners for Call Controls ---
            callButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const callType = button.dataset.callType;
                    const currentUser = button.dataset.user;
                    const recipient = currentUser === 'raushan' ? 'nisha' : 'raushan';
                    startCall(callType, recipient);
                });
            });

            acceptCallBtn.addEventListener('click', acceptCall);
            endCallBtn.addEventListener('click', () => endCall(true));

            toggleMicBtn.addEventListener('click', () => {
                const audioTrack = localStream.getAudioTracks()[0];
                if (audioTrack) {
                    audioTrack.enabled = !audioTrack.enabled;
                    toggleMicBtn.classList.toggle('active', !audioTrack.enabled);
                }
            });

            toggleVideoBtn.addEventListener('click', () => {
                const videoTrack = localStream.getVideoTracks()[0];
                if (videoTrack) {
                    videoTrack.enabled = !videoTrack.enabled;
                    toggleVideoBtn.classList.toggle('active', !videoTrack.enabled);
                }
            });

            toggleSpeakerBtn.addEventListener('click', async () => {
                if (!('setSinkId' in HTMLMediaElement.prototype)) {
                    alert('Your browser does not support changing audio output devices.');
                    return;
                }

                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const audioOutputs = devices.filter(device => device.kind === 'audiooutput');

                    if (audioOutputs.length < 2) {
                        alert('No alternative audio output device found.');
                        return;
                    }

                    // Simple toggle: if current is default, switch to the first non-default, and vice-versa.
                    const currentSinkId = remoteVideo.sinkId;
                    const defaultDevice = audioOutputs.find(d => d.deviceId === 'default');
                    const alternativeDevice = audioOutputs.find(d => d.deviceId !== 'default');

                    const newSinkId = (currentSinkId === defaultDevice.deviceId) ? alternativeDevice.deviceId : defaultDevice.deviceId;

                    await remoteVideo.setSinkId(newSinkId);
                    toggleSpeakerBtn.classList.toggle('active', newSinkId !== defaultDevice.deviceId);
                    console.log(`Audio output switched to: ${newSinkId}`);
                } catch (err) {
                    console.error('Error switching audio output:', err);
                    alert('Could not switch audio output.');
                }
            });

            flipCameraCallBtn.addEventListener('click', async () => {
                if (!localStream || !peerConnection) return;

                const videoTrack = localStream.getVideoTracks()[0];
                if (!videoTrack) return;

                // Toggle facing mode
                currentCallFacingMode = currentCallFacingMode === 'user' ? 'environment' : 'user';

                try {
                    // Get new stream with the new facing mode
                    const newStream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: currentCallFacingMode },
                        audio: true // Keep audio consistent
                    });
                    const newVideoTrack = newStream.getVideoTracks()[0];

                    // Find the video sender and replace the track
                    const sender = peerConnection.getSenders().find(s => s.track.kind === 'video');
                    if (sender) {
                        await sender.replaceTrack(newVideoTrack);
                    }

                    // Stop the old video track to release the camera
                    videoTrack.stop();

                    // Update localStream with the new video track (and existing audio track)
                    localStream.removeTrack(videoTrack);
                    localStream.addTrack(newVideoTrack);

                } catch (err) {
                    console.error('Error flipping camera:', err);
                    alert('Could not flip camera. It might not be supported on your device.');
                    // Revert facing mode on error
                    currentCallFacingMode = currentCallFacingMode === 'user' ? 'environment' : 'user';
                }
            });

            // Add a separate handler for the decline button in the incoming call view
            document.getElementById('end-call-btn-decline').addEventListener('click', () => endCall(true));


            function formatSeenDate(isoString) {
                const date = new Date(isoString);
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0'); // Month is 0-indexed
                const year = date.getFullYear();
                return `${day}-${month}-${year}`;
            }

            function setupWebSocket() {
                // Connect to the WebSocket server
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}`;
                socket = new WebSocket(wsUrl);

                socket.onopen = () => {
                    console.log('WebSocket connection established');
                    // If a user is already logged in (e.g., on a reconnect), re-register them.
                    // This is the key fix for the online/offline status.
                    if (activeUser) {
                        socket.send(JSON.stringify({ type: 'register', payload: { user: activeUser } }));
                        // Now that the user is registered, fetch the messages.
                        initializeApp();
                    } else if (!initialStatusLoaded) {
                        // If no user is logged in, ask the server for the current status of all users.
                        // This is for the initial load of the selection screen.
                        socket.send(JSON.stringify({ type: 'get_all_user_statuses' }));
                        initialStatusLoaded = true;
                    }
                };

                socket.onmessage = (event) => {
                    const eventData = JSON.parse(event.data);

                    switch (eventData.type) {
                        case 'new_message':
                            const message = eventData.payload;
                            // Prevent re-rendering of a message that already exists in the DOM.
                            if (!messageElements.has(message.id)) {
                                renderMessage(message);

                                // Play sound if the active user is the recipient of the message
                                if (activeUser && message.sender !== activeUser) {
                                    notificationSound.play().catch(e => console.error("Error playing sound:", e));
                                }

                                // If the current active user is the recipient, mark message as seen immediately
                                // Only mark as seen if the user is the recipient AND the window is currently focused.
                                if (activeUser && activeUser === message.recipient && !document.hidden) {
                                    setTimeout(() => {
                                        fetch('/api/messages/mark-as-seen', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ user: activeUser }) });
                                    }, 100);
                                }
                            }
                            break;
                        case 'typing':
                            const typingIndicator = eventData.user === 'raushan' ? nishaTypingIndicator : raushanTypingIndicator;
                            typingIndicator.classList.add('visible');
                            typingIndicator.parentElement.querySelector('.chat-messages').scrollTop = typingIndicator.parentElement.querySelector('.chat-messages').scrollHeight;
                            break;
                        case 'stop_typing':
                            const stopTypingIndicator = eventData.user === 'raushan' ? nishaTypingIndicator : raushanTypingIndicator;
                            stopTypingIndicator.classList.remove('visible');
                            break;
                        case 'chat_cleared':
                            raushanMessages.innerHTML = '';
                            nishaMessages.innerHTML = '';
                            messageElements.clear();
                            console.log('Chat history cleared on client.');
                            break;
                        case 'messages_seen':
                            eventData.payload.forEach(seenMessage => {
                                const messageTuple = messageElements.get(seenMessage.id);
                                if (messageTuple) {
                                    // The UI element to update is the one in the SENDER's chat window.
                                    // For example, if Nisha saw a message from Raushan, we update Raushan's message bubble.
                                    const messageToUpdate = seenMessage.sender === 'raushan'
                                        ? messageTuple.raushan
                                        : messageTuple.nisha;
                                    
                                    const statusEl = messageToUpdate.statusElement;
                                    if (statusEl && !statusEl.classList.contains('seen')) {
                                        statusEl.innerHTML = '‚úì‚úì';
                                        statusEl.classList.add('seen');
 
                                        let seenInfoDiv = messageToUpdate.querySelector('.message-seen-info');
                                        if (!seenInfoDiv) {
                                            seenInfoDiv = document.createElement('div');
                                            seenInfoDiv.className = 'message-seen-info';
                                            const seenDateSpan = document.createElement('span');
                                            seenDateSpan.className = 'seen-date';
                                            seenInfoDiv.appendChild(seenDateSpan);
                                            const seenTimeSpan = document.createElement('span'); // Create the time span
                                            seenTimeSpan.className = 'seen-time'; // Assign its class
                                            seenInfoDiv.appendChild(seenTimeSpan);
                                            messageToUpdate.appendChild(seenInfoDiv);
                                        }
                                        seenInfoDiv.querySelector('.seen-date').textContent = formatSeenDate(seenMessage.seen_at);
                                        seenInfoDiv.querySelector('.seen-time').textContent = formatSeenTime(seenMessage.seen_at);
                                    }
                                }
                            });
                            break;
                        case 'unread_count_update':
                            updateUnreadCounts();
                            break;
                        case 'user_status':
                            const { user, status } = eventData.payload;
                            updateUserStatusUI(user, status);
                            break;
                        case 'all_user_statuses':
                            // This handles the initial status load on the selection screen
                            const statuses = eventData.payload; // e.g., { raushan: 'online', nisha: 'offline' }
                            for (const user in statuses) {
                                updateUserStatusUI(user, statuses[user]);
                            }
                            break;
                        // --- WebRTC Signaling Cases ---
                        case 'call-offer':
                            handleIncomingCall(eventData.payload); // The payload here is for the call, not a user status.
                            break;
                        case 'call-answer':
                            handleCallAnswer(eventData.payload);
                            break;
                        case 'ice-candidate':
                            handleNewICECandidate(eventData.payload);
                            break;
                        case 'call-end':
                            endCall(false); // Don't send another end signal
                            break;
                        case 'call-reject':
                            alert(`${eventData.payload.from} rejected the call.`); endCall(false);
                            break;
                        case 'user-busy':
                            alert(`${eventData.payload.recipient} is busy.`); endCall(false);
                            break;
                        case 'call-recipient-offline':
                            // This is the new event from the server when the call recipient is not connected.
                            alert(`${eventData.payload.recipient} is offline.`);
                            // The server will create the missed call message, so the client just needs to end the call UI.
                            endCall(false);
                            break;
                        case 'peer-disconnected':
                            // This is the new event from the server when the other user's WebSocket closes.
                            if (isCallInProgress) {
                                console.log('Peer WebSocket disconnected. Attempting to reconnect...');
                                callStatusTextHeaderEl.textContent = 'Connecting...';
                                if (!reconnectionTimer) {
                                    reconnectionTimer = setTimeout(() => {
                                        console.log("Reconnection timeout after peer WS disconnect. Ending call.");
                                        endCall(true);
                                    }, RECONNECTION_TIMEOUT);
                                }
                            }
                            break;
                        // --- Voice Chat Signaling ---
                        case 'voice-chat-offer':
                            handleVoiceChatOffer(eventData.payload);
                            break;
                        case 'voice-chat-answer':
                            handleVoiceChatAnswer(eventData.payload);
                            break;
                        case 'voice-chat-ice-candidate':
                            handleVoiceChatICECandidate(eventData.payload);
                            break;
                        case 'voice-chat-end':
                            if (voiceChatPeerConnection) {
                                console.log("Received voice chat end signal.");
                                endVoiceChat();
                            }
                            break;
                        // --- Sound Alert ---
                        case 'sound_alert':
                            handleSoundAlert(eventData.payload.from);
                            break;

                            break;
                    }
                };

                socket.onclose = () => {
                    console.log('WebSocket connection closed. Attempting to reconnect...');
                    // Simple reconnect logic, will re-register on 'open' if a user is active
                    setTimeout(setupWebSocket, 3000);
                };

                socket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                };

                return socket;
            }

            function updateUserStatusUI(user, status) {
                const statusIndicators = [
                    document.getElementById(`${user}-status`), // In chat header
                    document.getElementById(`${user}-selection-status`) // On selection screen
                ];

                statusIndicators.forEach(indicator => {
                    if (!indicator) return;

                    const statusText = indicator.querySelector('.status-text');
                    if (status === 'online') {
                        indicator.classList.add('online');
                        statusText.textContent = 'Online';
                    } else {
                        indicator.classList.remove('online');
                        statusText.textContent = 'Offline';
                    }
                });
            }
            // Function to render a message to both chat windows
            function renderMessage(messageData) {
                const { id, sender, content, time_string: timeString, is_seen: isSeen, seen_at: seenAt } = messageData;

                // Function to create a message element with content and timestamp
                const createMessageElement = (msgContent) => { // This is a local helper function
                    const messageDiv = document.createElement('div');
                    messageDiv.classList.add('message');

                    if (msgContent.imageUrl) {
                        const imageEl = document.createElement('img');
                        imageEl.src = msgContent.imageUrl;
                        imageEl.className = 'message-image';
                        // Add click listener for zoom
                        imageEl.addEventListener('click', () => {
                            zoomedImage.src = imageEl.src;
                            imageZoomModal.classList.remove('hidden');
                            imageZoomModal.classList.add('visible');
                        });
                        messageDiv.appendChild(imageEl);
                    }

                    if (msgContent.videoUrl) {
                        const videoEl = document.createElement('video');
                        videoEl.src = msgContent.videoUrl;
                        videoEl.className = 'message-video';
                        videoEl.controls = true;
                        messageDiv.appendChild(videoEl);
                    }


                    if (msgContent.audioUrl) {
                        // Create a hidden audio element to control playback
                        const audioEl = document.createElement('audio');
                        audioEl.src = msgContent.audioUrl;
                        audioEl.className = 'message-audio';
                        messageDiv.appendChild(audioEl);
                        let audioDurationSpan;

                        // Create custom player UI
                        const playerDiv = document.createElement('div');
                        playerDiv.className = 'custom-audio-player';

                        const playBtn = document.createElement('button');
                        playBtn.className = 'play-pause-btn';
                        playBtn.innerHTML = '‚ñ∂'; // Play icon
                        
                        const waveformContainer = document.createElement('div');
                        waveformContainer.className = 'waveform-container';
                        const waveformBars = [];
                        const barCount = 40; // Number of bars in the waveform
                        for (let i = 0; i < barCount; i++) {
                            const bar = document.createElement('div');
                            bar.className = 'waveform-bar';
                            // Randomize height for a static waveform look
                            bar.style.height = `${Math.random() * 80 + 20}%`;
                            waveformContainer.appendChild(bar);
                            waveformBars.push(bar);
                        }

                        const durationEl = document.createElement('span');
                        durationEl.className = 'audio-duration';


                        // --- Custom Player Logic ---
                        const formatTime = (time) => {
                            const minutes = Math.floor(time / 60);
                            const seconds = Math.floor(time % 60).toString().padStart(2, '0');
                            return `${minutes}:${seconds}`;
                        };

                        audioEl.addEventListener('loadedmetadata', () => {
                            durationEl.textContent = formatTime(audioEl.duration);
                        });

                        playBtn.addEventListener('click', () => {
                            if (audioEl.paused) {
                                audioEl.play();
                                playBtn.innerHTML = '‚è∏';
                            } else {
                                audioEl.pause();
                                playBtn.innerHTML = '‚ñ∂';
                            }
                        });

                        audioEl.addEventListener('timeupdate', () => {
                            durationEl.textContent = formatTime(audioEl.currentTime);
                            const progress = audioEl.currentTime / audioEl.duration;
                            const playedBars = Math.floor(progress * barCount);
                            waveformBars.forEach((bar, index) => {
                                bar.classList.toggle('played', index < playedBars);
                            });
                        });

                        audioEl.addEventListener('ended', () => {
                            playBtn.innerHTML = '‚ñ∂';
                            durationEl.textContent = formatTime(audioEl.duration);
                        });

                        waveformContainer.addEventListener('click', (e) => {
                            const rect = waveformContainer.getBoundingClientRect();
                            const clickX = e.clientX - rect.left;
                            const newTime = (clickX / rect.width) * audioEl.duration;
                            audioEl.currentTime = newTime;
                        });

                        playerDiv.appendChild(playBtn);
                        playerDiv.appendChild(waveformContainer);
                        // Do NOT append durationEl to playerDiv. It will be added to the meta div later.
                        messageDiv.appendChild(playerDiv);
                        messageDiv.audioDurationElement = durationEl; // Attach it to the message div to be used later
                    }

                    if (msgContent.text?.trim()) {
                        const contentSpan = document.createElement('span');
                        contentSpan.className = 'message-content';
                        contentSpan.textContent = msgContent.text;
                        messageDiv.appendChild(contentSpan);
                    }

                    // Handle missed call rendering
                    if (msgContent.type === 'missed_call') {
                        const contentSpan = document.createElement('span');
                        contentSpan.className = 'message-content';
                        const icon = msgContent.callType === 'video' ? 'üìπ' : 'üìû';
                        contentSpan.textContent = `${icon} Missed ${msgContent.callType} call`;
                        contentSpan.style.fontStyle = 'italic';
                        contentSpan.style.opacity = '0.8';
                        messageDiv.appendChild(contentSpan);
                    }

                    // Handle call ended rendering
                    if (msgContent.type === 'call_ended') {
                        const formatDuration = (seconds) => {
                            if (seconds < 60) return `${seconds}s`;
                            const minutes = Math.floor(seconds / 60);
                            const remainingSeconds = seconds % 60;
                            return `${minutes}m ${remainingSeconds}s`;
                        };

                        const contentSpan = document.createElement('span');
                        contentSpan.className = 'message-content';
                        const icon = msgContent.callType === 'video' ? 'üìπ' : 'üìû';
                        const durationText = formatDuration(msgContent.duration);
                        contentSpan.textContent = `${icon} ${msgContent.callType.charAt(0).toUpperCase() + msgContent.callType.slice(1)} call ended ‚Ä¢ ${durationText}`;
                        contentSpan.style.fontStyle = 'italic';
                        contentSpan.style.opacity = '0.8';
                        messageDiv.appendChild(contentSpan);
                    }


                    // Add a placeholder for the status checkmark on sent messages
                    messageDiv.statusElement = document.createElement('span');
                    messageDiv.statusElement.className = 'message-status';

                    return messageDiv;
                };
                const createMetaElement = () => {
                    const metaDiv = document.createElement('div');
                    metaDiv.className = 'message-meta';
                    
                    // This inner div will hold the right-aligned items
                    const metaRightDiv = document.createElement('div');
                    metaRightDiv.className = 'message-meta-right';
 
                    const timeSpan = document.createElement('span');
                    timeSpan.className = 'message-timestamp';
                    timeSpan.textContent = timeString;
                    metaRightDiv.appendChild(timeSpan);
                    metaDiv.appendChild(metaRightDiv);

                    return { main: metaDiv, right: metaRightDiv };
                };

                // Create message for Raushan's window
                const raushanMessage = createMessageElement({ ...content });
                // Create message for Nisha's window
                const nishaMessage = createMessageElement({ ...content });

                if (sender === 'raushan') {
                    raushanMessage.classList.add('sent');
                    nishaMessage.classList.add('received');

                    // Add status to the sender's message
                    const { main: senderMeta, right: senderMetaRight } = createMetaElement();
                    if (content.type !== 'missed_call') { // Don't show status for missed calls
                        raushanMessage.statusElement.innerHTML = '‚úì'; // Sent (single check)
                        senderMetaRight.appendChild(raushanMessage.statusElement);
                    }
                    // If it's an audio message, add the duration to the meta section
                    if (raushanMessage.audioDurationElement) {
                        senderMeta.prepend(raushanMessage.audioDurationElement); // Add to the main meta div on the left
                    }
                    raushanMessage.appendChild(senderMeta);

                    const handleSeen = () => {
                        raushanMessage.statusElement.innerHTML = '‚úì‚úì';
                        raushanMessage.statusElement.classList.add('seen');
                        
                        // Use the data from the message object being rendered
                        if (seenAt) {
                            const seenInfoDiv = document.createElement('div');
                            seenInfoDiv.className = 'message-seen-info';
                            const seenDateSpan = document.createElement('span');
                            seenDateSpan.textContent = formatSeenDate(seenAt);
                            const seenTimeSpan = document.createElement('span');
                            seenTimeSpan.textContent = formatSeenTime(seenAt); // Use the correct variable
                            seenInfoDiv.appendChild(seenDateSpan);
                            seenInfoDiv.appendChild(seenTimeSpan);
                            raushanMessage.appendChild(seenInfoDiv);
                        }
                    };

                    if (isSeen) handleSeen();

                    // Add meta to receiver's message (without status)
                    const { main: receiverMetaForNisha } = createMetaElement();
                    if (nishaMessage.audioDurationElement) {
                        receiverMetaForNisha.prepend(nishaMessage.audioDurationElement); // Add to the main meta div on the left
                    }
                    nishaMessage.appendChild(receiverMetaForNisha);

                } else {
                    raushanMessage.classList.add('received');
                    nishaMessage.classList.add('sent');

                    // Add meta to receiver's message (without status)
                    const { main: receiverMetaForRaushan } = createMetaElement();
                    if (raushanMessage.audioDurationElement) {
                        receiverMetaForRaushan.prepend(raushanMessage.audioDurationElement); // Add to the main meta div on the left
                    }
                    raushanMessage.appendChild(receiverMetaForRaushan);

                    // Add status to the sender's message
                    const { main: senderMeta, right: senderMetaRight } = createMetaElement();
                    if (content.type !== 'missed_call') { // Don't show status for missed calls
                        nishaMessage.statusElement.innerHTML = '‚úì'; // Sent (single check)
                        senderMetaRight.appendChild(nishaMessage.statusElement);
                    }
                    // If it's an audio message, add the duration to the meta section
                    if (nishaMessage.audioDurationElement) {
                        senderMeta.prepend(nishaMessage.audioDurationElement); // Add to the main meta div on the left
                    }
                    nishaMessage.appendChild(senderMeta);

                    const handleSeen = () => {
                        nishaMessage.statusElement.innerHTML = '‚úì‚úì';
                        nishaMessage.statusElement.classList.add('seen');

                        // Use the data from the message object being rendered
                        if (seenAt) {
                            const seenInfoDiv = document.createElement('div');
                            seenInfoDiv.className = 'message-seen-info';
                            const seenDateSpan = document.createElement('span');
                            seenDateSpan.textContent = formatSeenDate(seenAt);
                            const seenTimeSpan = document.createElement('span');
                            seenTimeSpan.textContent = formatSeenTime(seenAt); // Use the correct variable
                            seenInfoDiv.appendChild(seenDateSpan);
                            seenInfoDiv.appendChild(seenTimeSpan);
                            nishaMessage.appendChild(seenInfoDiv);
                        }
                    };

                    if (isSeen) handleSeen();
                }

                raushanMessages.appendChild(raushanMessage);
                nishaMessages.appendChild(nishaMessage);

                // Store references to the message elements by ID
                messageElements.set(id, { raushan: raushanMessage, nisha: nishaMessage });


                // Scroll to the bottom
                raushanMessages.scrollTop = raushanMessages.scrollHeight;
                nishaMessages.scrollTop = nishaMessages.scrollHeight;
            }

            // Event listener for Raushan's form
            raushanForm.addEventListener('submit', async (e) => {
                e.preventDefault(); // Prevent page reload
                const messageData = {
                    sender: 'raushan',
                    content: { text: raushanInput.value },
                    timeString: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
                };
                await fetch('/api/messages', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(messageData)
                });
                clearTimeout(raushanTypingTimer); // Stop the typing timer
                raushanInput.value = ''; // Clear input field
            });

            // Event listener for Nisha's form
            nishaForm.addEventListener('submit', async (e) => {
                e.preventDefault(); // Prevent page reload
                const messageData = {
                    sender: 'nisha',
                    content: { text: nishaInput.value },
                    timeString: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                };
                await fetch('/api/messages', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(messageData)
                });
                clearTimeout(nishaTypingTimer); // Stop the typing timer
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({ type: 'stop_typing', user: 'nisha' }));
                }
                nishaInput.value = ''; // Clear input field
            });

            // --- Send message on Enter key press ---
            raushanInput.addEventListener('keydown', (e) => {
                // Check if Enter key is pressed and Shift key is not pressed
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault(); // Prevent adding a new line
                    raushanForm.requestSubmit(); // Programmatically submit the form
                }
            });

            nishaInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    nishaForm.requestSubmit();
                }
            });
            
            // --- Typing Indicator Logic ---
            raushanInput.addEventListener('input', () => {
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({ type: 'typing', user: 'raushan' }));
                }
                clearTimeout(raushanTypingTimer);
                raushanTypingTimer = setTimeout(() => {
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        socket.send(JSON.stringify({ type: 'stop_typing', user: 'raushan' }));
                    }
                }, 2000); // Hide after 2 seconds of inactivity
            });

            nishaInput.addEventListener('input', () => {
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({ type: 'typing', user: 'nisha' }));
                }
                clearTimeout(nishaTypingTimer);
                nishaTypingTimer = setTimeout(() => {
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        socket.send(JSON.stringify({ type: 'stop_typing', user: 'nisha' }));
                    }
                }, 2000); // Hide after 2 seconds of inactivity
            });

            // --- Image Sending Logic ---
            attachButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const user = button.dataset.user;
                    document.getElementById(`${user}-file-input`).click();
                });
            });

            let attachedFileUrl = null;
            let attachedFileType = null;

            fileInputs.forEach(input => {
                input.addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    activeUserForAttachment = input.id.includes('raushan') ? 'raushan' : 'nisha';
                    attachedFileType = file.type;

                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        attachedFileUrl = event.target.result;

                        // Show preview modal
                        attachmentPreviewModal.classList.remove('hidden');

                        if (attachedFileType.startsWith('video/')) {
                            attachmentPreviewImage.classList.add('hidden');
                            attachmentPreviewVideo.classList.remove('hidden');
                            attachmentPreviewVideo.src = attachedFileUrl;
                        } else {
                            attachmentPreviewVideo.classList.add('hidden');
                            attachmentPreviewImage.classList.remove('hidden');
                            attachmentPreviewImage.src = attachedFileUrl;
                        }
                    };
                    reader.readAsDataURL(file);

                    e.target.value = ''; // Reset input so the same file can be selected again
                });
            });

            const closeAttachmentPreview = () => {
                attachmentPreviewModal.classList.add('hidden');
                attachedFileUrl = null;
                attachedFileType = null;
                activeUserForAttachment = null;
                attachmentPreviewVideo.pause();
                attachmentPreviewVideo.src = "";
            };

            closeAttachmentPreviewBtn.addEventListener('click', closeAttachmentPreview);

            reattachFileBtn.addEventListener('click', () => {
                if (activeUserForAttachment) {
                    document.getElementById(`${activeUserForAttachment}-file-input`).click();
                }
            });

            sendAttachmentBtn.addEventListener('click', async () => {
                if (!activeUserForAttachment || !attachedFileUrl) return;

                const content = {};
                if (attachedFileType.startsWith('video/')) {
                    content.videoUrl = attachedFileUrl;
                } else {
                    content.imageUrl = attachedFileUrl;
                }

                const messageData = { sender: activeUserForAttachment, content, timeString: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) };
                await fetch('/api/messages', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(messageData) });
                closeAttachmentPreview();
            });

            // --- Camera Button Logic ---
            let cameraStreamTrack = null;
            let capturedImageDataUrl = null;
            let currentFacingMode = 'user'; // 'user' for front, 'environment' for back


            const openCamera = async (user) => {
                try {
                    // Stop any existing stream before starting a new one
                    if (cameraStreamTrack) {
                        cameraStreamTrack.stop();
                    }

                    const constraints = {
                        video: { facingMode: currentFacingMode },
                        audio: false
                    };
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    cameraStreamTrack = stream.getTracks()[0];
                    cameraStream.srcObject = stream;

                    // **THE FIX**: Add/remove 'mirrored' class based on which camera is active.
                    cameraStream.classList.toggle('mirrored', currentFacingMode === 'user');
                    cameraPreviewModal.classList.remove('hidden');
                    // Ensure we are in live view
                    cameraStream.classList.remove('hidden');
                    photoPreview.classList.add('hidden');
                    document.getElementById('live-camera-controls').classList.remove('hidden');
                    document.getElementById('live-camera-top-controls').classList.remove('hidden');

                    document.getElementById('preview-controls').classList.add('hidden');

                    activeUserForAttachment = user; // Set which user is capturing
                } catch (err) {
                    console.error("Error accessing camera:", err);
                    alert("Could not access the camera. Please check your browser permissions and ensure you are on a secure (HTTPS) connection.");
                }
            };

            const closeCamera = () => {
                if (cameraStreamTrack) {
                    cameraStreamTrack.stop();
                    cameraStreamTrack = null;
                }
                cameraPreviewModal.classList.add('hidden');
                capturedImageDataUrl = null;
                activeUserForAttachment = null;
            };

            cameraButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const user = button.dataset.user;
                    openCamera(user);
                });
            });

            closeCameraPreviewButton.addEventListener('click', closeCamera);

            capturePhotoButton.addEventListener('click', () => {
                const canvas = document.createElement('canvas');
                canvas.width = cameraStream.videoWidth;
                canvas.height = cameraStream.videoHeight;
                const context = canvas.getContext('2d');

                // If the stream is mirrored, we need to un-mirror the captured image
                if (currentFacingMode === 'user') {
                    context.translate(canvas.width, 0);
                    context.scale(-1, 1);
                }

                context.drawImage(cameraStream, 0, 0, canvas.width, canvas.height);

                capturedImageDataUrl = canvas.toDataURL('image/jpeg');
                photoPreview.src = capturedImageDataUrl;

                context.setTransform(1, 0, 0, 1, 0, 0); // Reset transform for next use

                // Switch to preview mode
                cameraStream.classList.add('hidden');
                photoPreview.classList.remove('hidden');
                document.getElementById('live-camera-controls').classList.add('hidden');
                document.getElementById('live-camera-top-controls').classList.add('hidden');
                document.getElementById('preview-controls').classList.remove('hidden');
            });

            retakePhotoButton.addEventListener('click', () => {
                // Switch back to live camera mode
                cameraStream.classList.remove('hidden');
                photoPreview.classList.add('hidden');
                document.getElementById('live-camera-controls').classList.remove('hidden');
                document.getElementById('live-camera-top-controls').classList.remove('hidden');
                document.getElementById('preview-controls').classList.add('hidden');
                capturedImageDataUrl = null;
            });

            flipCameraButton.addEventListener('click', () => {
                // Toggle between 'user' (front) and 'environment' (back)
                currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
                openCamera(activeUserForAttachment); // Re-open the camera with the new mode
            });

            toggleFlashButton.addEventListener('click', async () => {
                if (!cameraStreamTrack) return;

                const capabilities = cameraStreamTrack.getCapabilities();
                if (!capabilities.torch) {
                    alert('Flash is not available on this camera.');
                    return;
                }

                try {
                    const isFlashOn = cameraStreamTrack.getSettings().torch;
                    await cameraStreamTrack.applyConstraints({
                        advanced: [{ torch: !isFlashOn }]
                    });
                    toggleFlashButton.classList.toggle('active', !isFlashOn);
                } catch (err) {
                    console.error('Error toggling flash:', err);
                }
            });

            sendPhotoButton.addEventListener('click', async () => {
                if (!activeUserForAttachment || !capturedImageDataUrl) return;

                const messageData = {
                    sender: activeUserForAttachment,
                    content: { imageUrl: capturedImageDataUrl },
                    timeString: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                };

                try {
                    await fetch('/api/messages', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(messageData)
                    });
                } catch (error) {
                    console.error("Failed to send captured image:", error);
                    alert("Could not send the image. Please try again.");
                } finally {
                    // Close the camera preview after attempting to send
                    closeCamera();
                }
            });

            // --- Voice Recording Logic ---
            let mediaRecorder;
            let audioChunks = [];
            let isRecording = false;
            let recordedAudioBlob = null;

            voiceRecordButtons.forEach(button => {
                button.addEventListener('click', async () => {
                    const user = button.dataset.user;

                    if (isRecording) {
                        // Stop recording
                        mediaRecorder.stop();
                        button.classList.remove('recording');
                        button.innerHTML = 'üé§'; // Change icon back to mic
                        isRecording = false;
                    } else {
                        // Start recording
                        try {
                            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                            mediaRecorder = new MediaRecorder(stream);

                            mediaRecorder.ondataavailable = event => {
                                audioChunks.push(event.data);
                            };

                            mediaRecorder.onstop = () => {
                                recordedAudioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                                const audioUrl = URL.createObjectURL(recordedAudioBlob);
                                
                                // Show audio preview
                                showAudioPreview(user, audioUrl);

                                // Clean up
                                audioChunks = [];
                                stream.getTracks().forEach(track => track.stop()); // Stop microphone access
                            };

                            mediaRecorder.start();
                            button.classList.add('recording');
                            button.innerHTML = '‚ñ†'; // Change icon to a stop square
                            isRecording = true;

                        } catch (err) {
                            console.error("Error accessing microphone:", err);
                            alert("Could not access the microphone. Please check your browser permissions.");
                        }
                    }
                });
            });

            function showAudioPreview(user, audioUrl) {
                const inputArea = document.getElementById(`${user}-form`);
                const audioPreview = inputArea.querySelector('.audio-preview');
                const audioPlayer = audioPreview.querySelector('.preview-audio-player');
                const deleteButton = audioPreview.querySelector('.delete-audio-button');
                const sendButton = audioPreview.querySelector('.send-audio-button');

                // Hide regular input elements
                inputArea.querySelector('.chat-input').classList.add('hidden');
                inputArea.querySelector('.attach-button').classList.add('hidden');
                inputArea.querySelector('.camera-button').classList.add('hidden');
                inputArea.querySelector('.voice-record-button').classList.add('hidden');
                inputArea.querySelector('button[type="submit"]').classList.add('hidden');

                // Show preview
                audioPlayer.src = audioUrl;
                audioPreview.classList.remove('hidden');

                // --- Event Listeners for Preview ---
                const sendAudioHandler = async () => {
                    const reader = new FileReader();
                    reader.readAsDataURL(recordedAudioBlob);
                    reader.onloadend = async () => {
                        const base64Audio = reader.result;
                        const messageData = {
                            sender: user,
                            content: { audioUrl: base64Audio },
                            timeString: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                        };
                        await fetch('/api/messages', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(messageData)
                        });
                        hideAudioPreview(user); // Clean up UI after sending
                    };
                };

                const deleteAudioHandler = () => {
                    hideAudioPreview(user);
                };

                // Use .onclick to easily replace listeners
                sendButton.onclick = sendAudioHandler;
                deleteButton.onclick = deleteAudioHandler;
            }

            function hideAudioPreview(user) {
                const inputArea = document.getElementById(`${user}-form`);
                const audioPreview = inputArea.querySelector('.audio-preview');
                
                // Hide preview and show regular inputs
                audioPreview.classList.add('hidden');
                inputArea.querySelector('.chat-input').classList.remove('hidden');
                inputArea.querySelector('.attach-button').classList.remove('hidden');
                inputArea.querySelector('.camera-button').classList.remove('hidden');
                inputArea.querySelector('.voice-record-button').classList.remove('hidden');
                inputArea.querySelector('button[type="submit"]').classList.remove('hidden');
            }

            // --- Image Zoom Logic ---
            const closeZoomModal = () => {
                imageZoomModal.classList.remove('visible');
                // Use a timeout to allow the fade-out animation to complete before hiding
                setTimeout(() => imageZoomModal.classList.add('hidden'), 300);
            };

            closeZoomButton.addEventListener('click', closeZoomModal);
            imageZoomModal.addEventListener('click', (e) => { if (e.target === imageZoomModal) closeZoomModal(); });

            // --- Login and View Switching Logic ---
            loginForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                 const username = usernameInput.value;
                 const password = passwordInput.value;
                 let userKey = null;
 
                 if (username === 'Raushan_143' && password === USERS.Raushan_143) {
                     userKey = 'raushan';
                 } else if (username === 'Nisha_143' && password === USERS.Nisha_143) {
                     userKey = 'nisha';
                 }
 
                 if (userKey) {
                     activeUser = userKey; // Set the active user
 
                     // Stop polling for unread messages since we're in the chat
                     clearInterval(unreadCountInterval);
 
                     // Show the correct chat box and hide the other one
                     document.getElementById('raushan-chat').classList.toggle('hidden', activeUser !== 'raushan');
                     document.getElementById('nisha-chat').classList.toggle('hidden', activeUser !== 'nisha');
 
                     // Hide login screen and show chat app
                     selectionContainer.classList.add('hidden');
                     chatAppContainer.classList.remove('hidden');
                     document.body.classList.add('chat-active');
 
                     // Connect to WebSocket and initialize the app *after* connection
                     setupWebSocket();
 
                 } else {
                     errorMessage.textContent = 'Invalid User ID or Password!';
                     loginForm.classList.add('shake');
                     setTimeout(() => loginForm.classList.remove('shake'), 500);
                 }
            });

            switchUserButtons.forEach(button => {
                button.addEventListener('click', () => {
                    chatAppContainer.classList.add('hidden');
                    document.getElementById('raushan-chat').classList.add('hidden');
                    document.getElementById('nisha-chat').classList.add('hidden');

                    selectionContainer.classList.remove('hidden');
                    document.body.classList.remove('chat-active'); // Revert to the original background
                    activeUser = null;
                    // Disconnect WebSocket when logging out to unregister the user on the server
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        socket.close();
                    }
                    socket = null; // Fully clear the socket variable

                    updateUnreadCounts(); // Check counts immediately
                    unreadCountInterval = setInterval(updateUnreadCounts, 5000); // Restart polling
                });
            });

            // --- Voice Chat Button Listeners ---
            voiceChatButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const currentUser = button.dataset.user;
                    const recipient = currentUser === 'raushan' ? 'nisha' : 'raushan';
                    startVoiceChat(recipient);
                });
            });
            endVoiceChatBtn.addEventListener('click', endVoiceChat);

            // --- Sound Alert Button Listeners ---
            soundAlertButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const currentUser = button.dataset.user;
                    const recipient = currentUser === 'raushan' ? 'nisha' : 'raushan';
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        socket.send(JSON.stringify({ type: 'sound_alert', payload: { from: currentUser, to: recipient } }));
                    }
                });
            });
            stopAlertBtn.addEventListener('click', stopSoundAlert);

            // --- Mark as Seen on Window Focus ---
            window.addEventListener('focus', () => {
                // If a user is logged in and the window gets focus, mark messages as seen.
                if (activeUser && socket && socket.readyState === WebSocket.OPEN) {
                    fetch('/api/messages/mark-as-seen', {
                        method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ user: activeUser })
                    });
                }
            });

            // --- Clear History Logic ---
            clearHistoryButtons.forEach(button => {
                button.addEventListener('click', async () => {
                    if (confirm('Are you sure you want to delete all chat history? This cannot be undone.')) {
                        try {
                            const response = await fetch('/api/messages', {
                                method: 'DELETE',
                            });

                            if (!response.ok) {
                                throw new Error('Server failed to clear history.');
                            }
                            // The WebSocket broadcast will handle clearing the UI.
                        } catch (error) {
                            console.error('Failed to clear chat history:', error);
                            alert('Could not clear chat history. Please try again.');
                        }
                    }
                });
            });

            // --- Refresh Chat Logic ---
            refreshButtons.forEach(button => {
                button.addEventListener('click', () => {
                    initializeApp(); // Re-fetch and re-render
                });
            })

            // --- Header Menu Logic (with animation) ---
            document.querySelectorAll('.menu-toggle-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent the window click from closing it immediately
                    const dropdown = button.nextElementSibling;
                    // Hide other open dropdowns
                    document.querySelectorAll('.menu-dropdown.visible').forEach(d => {
                        if (d !== dropdown) d.classList.remove('visible');
                    });
                    // Toggle the current one
                    dropdown.classList.toggle('visible');
                });
            });

            // Close dropdown when clicking anywhere else
            window.addEventListener('click', () => {
                document.querySelectorAll('.menu-dropdown').forEach(dropdown => {
                    dropdown.classList.remove('visible');
                });
            });

            // --- Unread Count Logic ---
            async function updateUnreadCounts() {
                // Fetch for Raushan (messages sent by Nisha)
                const raushanRes = await fetch('/api/messages/unread-count?user=raushan');
                const raushanData = await raushanRes.json();
                const raushanBadge = document.getElementById('raushan-notification');
                if (raushanData.count > 0) {
                    raushanBadge.textContent = raushanData.count;
                    raushanBadge.classList.remove('hidden');
                } else {
                    raushanBadge.classList.add('hidden');
                }

                // Fetch for Nisha (messages sent by Raushan)
                const nishaRes = await fetch('/api/messages/unread-count?user=nisha');
                const nishaData = await nishaRes.json();
                const nishaBadge = document.getElementById('nisha-notification');
                if (nishaData.count > 0) {
                    nishaBadge.textContent = nishaData.count;
                    nishaBadge.classList.remove('hidden');
                } else {
                    nishaBadge.classList.add('hidden');
                }
            }

            // --- Load and Render Initial Data ---
            async function initializeApp() {
                try {
                    const response = await fetch('/api/messages');
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const messages = await response.json();
                    
                    raushanMessages.innerHTML = ''; // Clear existing messages
                    nishaMessages.innerHTML = '';   // Also clear the other chat window
                    messageElements.clear();
                    messages.forEach(msg => renderMessage(msg));
                } catch (error) {
                    console.error("Failed to fetch initial messages:", error);
                }
            }
            
            // Initial setup when page loads
            setupWebSocket(); // Connect immediately to get live status updates
            updateUnreadCounts();
            unreadCountInterval = setInterval(updateUnreadCounts, 5000); // Poll every 5 seconds

        });
    </script>

</body>
</html>
</body>
</html>